/* tslint:disable */
/* eslint-disable */
/**
 * PubKey API
 * The Social Solana Explorer
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  id: string
  /**
   *
   * @type {User}
   * @memberof Account
   */
  discoveredBy: User | null
  /**
   *
   * @type {Identity}
   * @memberof Account
   */
  identity: Identity | null
  /**
   *
   * @type {Account}
   * @memberof Account
   */
  owner: Account | null
  /**
   *
   * @type {Array<Account>}
   * @memberof Account
   */
  tokens: Array<Account> | null
  /**
   *
   * @type {string}
   * @memberof Account
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Account
   */
  program: string
  /**
   *
   * @type {string}
   * @memberof Account
   */
  address: string
  /**
   *
   * @type {NetworkType}
   * @memberof Account
   */
  network: NetworkType
  /**
   *
   * @type {AccountType}
   * @memberof Account
   */
  type: AccountType
}

/**
 *
 * @export
 * @enum {string}
 */

export const AccountType = {
  Account: 'Account',
  BonfidaDomain: 'BonfidaDomain',
  BonfidaTwitter: 'BonfidaTwitter',
  Mint: 'Mint',
  Program: 'Program',
  Token: 'Token',
  System: 'System',
} as const

export type AccountType = (typeof AccountType)[keyof typeof AccountType]

/**
 *
 * @export
 * @interface Cluster
 */
export interface Cluster {
  /**
   *
   * @type {string}
   * @memberof Cluster
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Cluster
   */
  name: string
  /**
   *
   * @type {ClusterType}
   * @memberof Cluster
   */
  type: ClusterType
  /**
   *
   * @type {string}
   * @memberof Cluster
   */
  endpoint: string
  /**
   *
   * @type {string}
   * @memberof Cluster
   */
  explorerUrl: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const ClusterType = {
  Custom: 'Custom',
  Devnet: 'Devnet',
  Mainnet: 'Mainnet',
  Testnet: 'Testnet',
} as const

export type ClusterType = (typeof ClusterType)[keyof typeof ClusterType]

/**
 *
 * @export
 * @interface Config
 */
export interface Config {
  /**
   *
   * @type {ConfigApi}
   * @memberof Config
   */
  api: ConfigApi | null
  /**
   *
   * @type {ConfigApp}
   * @memberof Config
   */
  app: ConfigApp | null
  /**
   *
   * @type {Cluster}
   * @memberof Config
   */
  cluster: Cluster | null
  /**
   *
   * @type {Array<Cluster>}
   * @memberof Config
   */
  clusters: Array<Cluster> | null
  /**
   *
   * @type {User}
   * @memberof Config
   */
  user: User | null
}
/**
 *
 * @export
 * @interface ConfigApi
 */
export interface ConfigApi {
  /**
   *
   * @type {string}
   * @memberof ConfigApi
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ConfigApi
   */
  version: string
  /**
   *
   * @type {string}
   * @memberof ConfigApi
   */
  url: string
}
/**
 *
 * @export
 * @interface ConfigApp
 */
export interface ConfigApp {
  /**
   *
   * @type {string}
   * @memberof ConfigApp
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof ConfigApp
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ConfigApp
   */
  url: string
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
  /**
   *
   * @type {string}
   * @memberof Identity
   */
  id: string
  /**
   *
   * @type {object}
   * @memberof Identity
   */
  provider: object
  /**
   *
   * @type {string}
   * @memberof Identity
   */
  providerId: string
  /**
   *
   * @type {object}
   * @memberof Identity
   */
  profile?: object | null
  /**
   *
   * @type {boolean}
   * @memberof Identity
   */
  verified: boolean
}
/**
 *
 * @export
 * @enum {string}
 */

export const IdentityProvider = {
  Discord: 'Discord',
  Github: 'Github',
  Solana: 'Solana',
} as const

export type IdentityProvider = (typeof IdentityProvider)[keyof typeof IdentityProvider]

/**
 *
 * @export
 * @enum {string}
 */

export const NetworkType = {
  SolanaDevnet: 'SolanaDevnet',
  SolanaMainnet: 'SolanaMainnet',
  SolanaTestnet: 'SolanaTestnet',
} as const

export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType]

/**
 *
 * @export
 * @interface Page
 */
export interface Page {
  /**
   *
   * @type {string}
   * @memberof Page
   */
  id?: string | null
  /**
   *
   * @type {PageStatus}
   * @memberof Page
   */
  status: PageStatus
  /**
   *
   * @type {PageType}
   * @memberof Page
   */
  type: PageType
  /**
   *
   * @type {string}
   * @memberof Page
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof Page
   */
  color?: string | null
  /**
   *
   * @type {string}
   * @memberof Page
   */
  description?: string | null
  /**
   *
   * @type {string}
   * @memberof Page
   */
  viewUrl?: string | null
  /**
   *
   * @type {string}
   * @memberof Page
   */
  siteUrl?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Page
   */
  urls?: Array<string> | null
  /**
   *
   * @type {User}
   * @memberof Page
   */
  owner?: User | null
  /**
   *
   * @type {Array<PageBlock>}
   * @memberof Page
   */
  blocks?: Array<PageBlock> | null
}

/**
 *
 * @export
 * @interface PageBlock
 */
export interface PageBlock {
  /**
   *
   * @type {string}
   * @memberof PageBlock
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof PageBlock
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof PageBlock
   */
  order: number
  /**
   *
   * @type {object}
   * @memberof PageBlock
   */
  data?: object | null
  /**
   *
   * @type {PageBlockType}
   * @memberof PageBlock
   */
  type: PageBlockType
}

/**
 *
 * @export
 * @enum {string}
 */

export const PageBlockType = {
  Header: 'Header',
  Link: 'Link',
} as const

export type PageBlockType = (typeof PageBlockType)[keyof typeof PageBlockType]

/**
 *
 * @export
 * @enum {string}
 */

export const PageStatus = {
  Demo: 'Demo',
  Draft: 'Draft',
  Published: 'Published',
} as const

export type PageStatus = (typeof PageStatus)[keyof typeof PageStatus]

/**
 *
 * @export
 * @enum {string}
 */

export const PageType = {
  Degen: 'Degen',
  Gaming: 'Gaming',
  Personal: 'Personal',
  Professional: 'Professional',
} as const

export type PageType = (typeof PageType)[keyof typeof PageType]

/**
 *
 * @export
 * @interface RequestChallenge
 */
export interface RequestChallenge {
  /**
   *
   * @type {string}
   * @memberof RequestChallenge
   */
  challenge: string
  /**
   *
   * @type {string}
   * @memberof RequestChallenge
   */
  expiresAt: string
  /**
   *
   * @type {string}
   * @memberof RequestChallenge
   */
  publicKey: string
  /**
   *
   * @type {string}
   * @memberof RequestChallenge
   */
  message: string
}
/**
 *
 * @export
 * @interface ResponseChallengeOptions
 */
export interface ResponseChallengeOptions {
  /**
   *
   * @type {string}
   * @memberof ResponseChallengeOptions
   */
  challenge: string
  /**
   *
   * @type {string}
   * @memberof ResponseChallengeOptions
   */
  publicKey: string
  /**
   *
   * @type {string}
   * @memberof ResponseChallengeOptions
   */
  signature: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string
  /**
   *
   * @type {number}
   * @memberof User
   */
  pid?: number | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  bio: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  avatarUrl: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  metaUrl?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  profileUrl?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  publicKey?: string | null
  /**
   *
   * @type {UserRole}
   * @memberof User
   */
  role?: UserRole
  /**
   *
   * @type {UserStatus}
   * @memberof User
   */
  status?: UserStatus
  /**
   *
   * @type {Array<Identity>}
   * @memberof User
   */
  identities?: Array<Identity> | null
  /**
   *
   * @type {number}
   * @memberof User
   */
  followersCount?: number | null
  /**
   *
   * @type {number}
   * @memberof User
   */
  followingCount?: number | null
}

/**
 *
 * @export
 * @enum {string}
 */

export const UserRole = {
  Admin: 'Admin',
  User: 'User',
} as const

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

/**
 *
 * @export
 * @enum {string}
 */

export const UserStatus = {
  Active: 'Active',
  Created: 'Created',
  Inactive: 'Inactive',
} as const

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestChallenge: async (publicKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'publicKey' is not null or undefined
      assertParamExists('requestChallenge', 'publicKey', publicKey)
      const localVarPath = `/api/auth/request-challenge/{publicKey}`.replace(
        `{${'publicKey'}}`,
        encodeURIComponent(String(publicKey)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {ResponseChallengeOptions} responseChallengeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondChallenge: async (
      responseChallengeOptions: ResponseChallengeOptions,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'responseChallengeOptions' is not null or undefined
      assertParamExists('respondChallenge', 'responseChallengeOptions', responseChallengeOptions)
      const localVarPath = `/api/auth/respond-challenge`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        responseChallengeOptions,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestChallenge(
      publicKey: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestChallenge>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestChallenge(publicKey, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {ResponseChallengeOptions} responseChallengeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async respondChallenge(
      responseChallengeOptions: ResponseChallengeOptions,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.respondChallenge(responseChallengeOptions, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<boolean> {
      return localVarFp.logout(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me(options?: any): AxiosPromise<User> {
      return localVarFp.me(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestChallenge(publicKey: string, options?: any): AxiosPromise<RequestChallenge> {
      return localVarFp.requestChallenge(publicKey, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {ResponseChallengeOptions} responseChallengeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondChallenge(responseChallengeOptions: ResponseChallengeOptions, options?: any): AxiosPromise<User> {
      return localVarFp.respondChallenge(responseChallengeOptions, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  logout(options?: AxiosRequestConfig): AxiosPromise<boolean>

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  me(options?: AxiosRequestConfig): AxiosPromise<User>

  /**
   *
   * @summary
   * @param {string} publicKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  requestChallenge(publicKey: string, options?: AxiosRequestConfig): AxiosPromise<RequestChallenge>

  /**
   *
   * @summary
   * @param {ResponseChallengeOptions} responseChallengeOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApiInterface
   */
  respondChallenge(responseChallengeOptions: ResponseChallengeOptions, options?: AxiosRequestConfig): AxiosPromise<User>
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public me(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .me(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} publicKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public requestChallenge(publicKey: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .requestChallenge(publicKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {ResponseChallengeOptions} responseChallengeOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public respondChallenge(responseChallengeOptions: ResponseChallengeOptions, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .respondChallenge(responseChallengeOptions, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfig(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ConfigApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: any): AxiosPromise<Config> {
      return localVarFp.getConfig(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigApi - interface
 * @export
 * @interface ConfigApi
 */
export interface ConfigApiInterface {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApiInterface
   */
  getConfig(options?: AxiosRequestConfig): AxiosPromise<Config>
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI implements ConfigApiInterface {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public getConfig(options?: AxiosRequestConfig) {
    return ConfigApiFp(this.configuration)
      .getConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSolanaFeatureControllerBonfidaLookup: async (
      publicKey: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'publicKey' is not null or undefined
      assertParamExists('apiSolanaFeatureControllerBonfidaLookup', 'publicKey', publicKey)
      const localVarPath = `/api/solana/bonfida/lookup/{publicKey}`.replace(
        `{${'publicKey'}}`,
        encodeURIComponent(String(publicKey)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} address
     * @param {NetworkType} network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (
      address: string,
      network: NetworkType,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('getAccount', 'address', address)
      // verify required parameter 'network' is not null or undefined
      assertParamExists('getAccount', 'network', network)
      const localVarPath = `/api/account/get-account/{network}/{address}`
        .replace(`{${'address'}}`, encodeURIComponent(String(address)))
        .replace(`{${'network'}}`, encodeURIComponent(String(network)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSolanaFeatureControllerBonfidaLookup(
      publicKey: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSolanaFeatureControllerBonfidaLookup(
        publicKey,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} address
     * @param {NetworkType} network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      address: string,
      network: NetworkType,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(address, network, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSolanaFeatureControllerBonfidaLookup(publicKey: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiSolanaFeatureControllerBonfidaLookup(publicKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} address
     * @param {NetworkType} network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(address: string, network: NetworkType, options?: any): AxiosPromise<Account> {
      return localVarFp.getAccount(address, network, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @param {string} publicKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  apiSolanaFeatureControllerBonfidaLookup(publicKey: string, options?: AxiosRequestConfig): AxiosPromise<void>

  /**
   *
   * @summary
   * @param {string} address
   * @param {NetworkType} network
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getAccount(address: string, network: NetworkType, options?: AxiosRequestConfig): AxiosPromise<Account>
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @param {string} publicKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public apiSolanaFeatureControllerBonfidaLookup(publicKey: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .apiSolanaFeatureControllerBonfidaLookup(publicKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} address
   * @param {NetworkType} network
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAccount(address: string, network: NetworkType, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getAccount(address, network, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageById: async (pageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('getPageById', 'pageId', pageId)
      const localVarPath = `/api/page/get-page-by-id/{pageId}`.replace(
        `{${'pageId'}}`,
        encodeURIComponent(String(pageId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageByUrl: async (url: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists('getPageByUrl', 'url', url)
      const localVarPath = `/api/page/get-page-by-url`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (url !== undefined) {
        localVarQueryParameter['url'] = url
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageById(
      pageId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageById(pageId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageByUrl(
      url: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageByUrl(url, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PageApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageById(pageId: string, options?: any): AxiosPromise<Page> {
      return localVarFp.getPageById(pageId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageByUrl(url: string, options?: any): AxiosPromise<Page> {
      return localVarFp.getPageByUrl(url, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * PageApi - interface
 * @export
 * @interface PageApi
 */
export interface PageApiInterface {
  /**
   *
   * @summary
   * @param {string} pageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PageApiInterface
   */
  getPageById(pageId: string, options?: AxiosRequestConfig): AxiosPromise<Page>

  /**
   *
   * @summary
   * @param {string} url
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PageApiInterface
   */
  getPageByUrl(url: string, options?: AxiosRequestConfig): AxiosPromise<Page>
}

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI implements PageApiInterface {
  /**
   *
   * @summary
   * @param {string} pageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PageApi
   */
  public getPageById(pageId: string, options?: AxiosRequestConfig) {
    return PageApiFp(this.configuration)
      .getPageById(pageId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} url
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PageApi
   */
  public getPageByUrl(url: string, options?: AxiosRequestConfig) {
    return PageApiFp(this.configuration)
      .getPageByUrl(url, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserById', 'userId', userId)
      const localVarPath = `/api/user/get-user-by-id/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} providerId
     * @param {IdentityProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByIdentity: async (
      providerId: string,
      provider: IdentityProvider,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('getUserByIdentity', 'providerId', providerId)
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('getUserByIdentity', 'provider', provider)
      const localVarPath = `/api/user/get-user-by-identity/{provider}/{providerId}`
        .replace(`{${'providerId'}}`, encodeURIComponent(String(providerId)))
        .replace(`{${'provider'}}`, encodeURIComponent(String(provider)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByUsername: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getUserByUsername', 'username', username)
      const localVarPath = `/api/user/get-user-by-username/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meta: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('meta', 'username', username)
      const localVarPath = `/api/user/meta/{username}`.replace(`{${'username'}}`, encodeURIComponent(String(username)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      userId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} providerId
     * @param {IdentityProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserByIdentity(
      providerId: string,
      provider: IdentityProvider,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIdentity(providerId, provider, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserByUsername(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meta(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meta(username, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(userId: string, options?: any): AxiosPromise<User> {
      return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} providerId
     * @param {IdentityProvider} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByIdentity(providerId: string, provider: IdentityProvider, options?: any): AxiosPromise<User> {
      return localVarFp.getUserByIdentity(providerId, provider, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByUsername(username: string, options?: any): AxiosPromise<User> {
      return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meta(username: string, options?: any): AxiosPromise<User> {
      return localVarFp.meta(username, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
  /**
   *
   * @summary
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiInterface
   */
  getUserById(userId: string, options?: AxiosRequestConfig): AxiosPromise<User>

  /**
   *
   * @summary
   * @param {string} providerId
   * @param {IdentityProvider} provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiInterface
   */
  getUserByIdentity(providerId: string, provider: IdentityProvider, options?: AxiosRequestConfig): AxiosPromise<User>

  /**
   *
   * @summary
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiInterface
   */
  getUserByUsername(username: string, options?: AxiosRequestConfig): AxiosPromise<User>

  /**
   *
   * @summary
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiInterface
   */
  meta(username: string, options?: AxiosRequestConfig): AxiosPromise<User>
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
  /**
   *
   * @summary
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserById(userId: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserById(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} providerId
   * @param {IdentityProvider} provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserByIdentity(providerId: string, provider: IdentityProvider, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserByIdentity(providerId, provider, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserByUsername(username: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserByUsername(username, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public meta(username: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .meta(username, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
